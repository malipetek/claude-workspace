#!/bin/bash

#══════════════════════════════════════════════════════════════════════════════
#  CLAUDE WORKSPACE
#══════════════════════════════════════════════════════════════════════════════
#
#  DESCRIPTION:
#    Workspace manager for Claude Code with Ghostty split-pane integration.
#    Quickly switch between projects and launch Claude with dev processes.
#
#  USAGE:
#    claude-workspace                    # Interactive project selector
#    claude-workspace <project_name>     # Open specific project
#    claude-workspace setup              # Run setup wizard
#    claude-workspace add <path>         # Add project to registry
#    claude-workspace --simple <name>    # Launch Claude only (no workspace)
#
#  WORKSPACE INTEGRATION:
#    If a project has .claude-workspace.json, it will automatically:
#    - Open Ghostty with split panes
#    - Run Claude on the left
#    - Run dev processes on the right
#
#══════════════════════════════════════════════════════════════════════════════

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
SCRIPT_DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
REGISTRY="$HOME/.claude-workspace/registry.json"
VERSION="1.4.2"

# Theme colors (matching menu.sh polished theme)
NC='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'

# Semantic colors - 256-color codes for better terminal compatibility
PRIMARY='\033[38;5;216m'          # Light peach/orange
PRIMARY_BG='\033[48;5;216m'
PRIMARY_FG='\033[38;5;234m'       # Dark text on primary bg

TEXT='\033[38;5;252m'             # Light gray
TEXT_MUTED='\033[38;5;245m'       # Muted gray
TEXT_DIM='\033[38;5;240m'         # Dimmer gray

ACCENT='\033[38;5;183m'           # Purple accent
SUCCESS='\033[38;5;114m'          # Green
WARNING='\033[38;5;215m'          # Orange
ERROR='\033[38;5;203m'            # Red

# Cursor positioning functions
goto_row() {
    printf '\033[%d;1H' "$1"
}

clear_line() {
    printf '\033[K'
}

clear_below() {
    printf '\033[J'
}

hide_cursor() {
    printf '\033[?25l'
}

show_cursor() {
    printf '\033[?25h'
}

enter_alt_screen() {
    tput smcup 2>/dev/null || printf '\033[?1049h'
}

exit_alt_screen() {
    tput rmcup 2>/dev/null || printf '\033[?1049l'
}

show_help() {
    cat << 'EOF'
╔══════════════════════════════════════════════════════════════════════════════╗
║  CLAUDE WORKSPACE                                                            ║
║  Workspace manager for Claude Code with AI delegation                        ║
╚══════════════════════════════════════════════════════════════════════════════╝

USAGE:
  claude-workspace                      Interactive project selector
  claude-workspace <project_name>       Open specific project
  claude-workspace setup                Run setup wizard
  claude-workspace settings             Configure AI tools & delegation
  claude-workspace add <path>           Add project to registry
  claude-workspace list                 List registered projects
  claude-workspace update               Update to latest version
  claude-workspace --simple <project>   Launch Claude only (no workspace)
  claude-workspace --help               Show this help

WORKSPACE MODE:
  If the project has .claude-workspace.json, it opens Ghostty with split panes:

  ┌─────────────────┬─────────────────┐
  │                 │   Dev Process 1 │
  │     Claude      ├─────────────────┤
  │      Code       │   Dev Process 2 │
  │                 ├─────────────────┤
  │                 │   Dev Process 3 │
  └─────────────────┴─────────────────┘

CONFIG FILE (.claude-workspace.json):
  Create this file in your project root to define dev processes:

  {
    "processes": [
      {
        "name": "frontend",
        "command": "pnpm dev",
        "cwd": "./frontend"
      },
      {
        "name": "backend",
        "command": "pnpm start:dev",
        "cwd": "./backend"
      },
      {
        "name": "database",
        "command": "docker compose up db",
        "cwd": "."
      },
      {
        "name": "storybook",
        "command": "pnpm storybook",
        "cwd": "./frontend"
      }
    ]
  }

  Process options:
    name      Display name for the process (shown in terminal title)
    command   Shell command to run (supports any shell command)
    cwd       Working directory relative to project root ("." for root)

AI DELEGATION:
  Claude can delegate tasks to other AI tools (Gemini, OpenCode, etc.)

  Configure with: claude-workspace settings

  Delegation modes:
    --visible    Watch AI work in a split terminal pane
    --branch     Isolate work on a feature branch (prevents conflicts)

  Delegation levels (0-4):
    0: Disabled   - Claude handles everything
    1: Minimal    - Only research/summarization
    2: Moderate   - Routine tasks (tests, types, docs)
    3: Aggressive - Most implementation, Claude reviews
    4: Orchestrator - Claude only orchestrates

KEYBOARD SHORTCUTS (Interactive Mode):
  ↑/↓               Navigate projects
  Enter             Launch project
  w                 Force workspace mode
  s                 Force simple mode (Claude only)
  q                 Quit

MORE INFO:
  https://github.com/malipetek/claude-workspace

EOF
}

# Function to launch a project
launch_project() {
    local project_path="$1"
    local force_mode="$2"  # "workspace", "simple", or ""
    local project_name=$(basename "$project_path")

    local workspace_config="$project_path/.claude-workspace.json"
    local has_workspace=false

    if [ -f "$workspace_config" ]; then
        has_workspace=true
    fi

    echo ""
    echo "╔══════════════════════════════════════════════════════════════════════════════╗"
    echo "║  Launching: $project_name"
    echo "╚══════════════════════════════════════════════════════════════════════════════╝"
    echo ""
    echo "Path: $project_path"

    # Determine launch mode
    local use_workspace=false

    if [ "$force_mode" = "workspace" ]; then
        if [ "$has_workspace" = true ]; then
            use_workspace=true
        else
            echo "Warning: No .claude-workspace.json found, launching Claude only"
        fi
    elif [ "$force_mode" = "simple" ]; then
        use_workspace=false
    elif [ "$has_workspace" = true ]; then
        use_workspace=true
    fi

    if [ "$use_workspace" = true ]; then
        echo "Mode: Workspace (Ghostty split panes)"
        echo ""

        # Show processes that will be started
        local process_count=$(jq '.processes | length' "$workspace_config")
        echo "Dev processes ($process_count):"
        for i in $(seq 0 $(($process_count - 1))); do
            local name=$(jq -r ".processes[$i].name" "$workspace_config")
            local cmd=$(jq -r ".processes[$i].command" "$workspace_config")
            echo "  [$((i+1))] $name: $cmd"
        done
        echo ""

        # Launch workspace
        exec "$SCRIPT_DIR/workspace.sh" "$project_path"
    else
        echo "Mode: Simple (Claude only)"
        echo ""

        if [ "$has_workspace" = true ]; then
            echo "Tip: This project has .claude-workspace.json"
            echo "     Run 'claude-workspace $project_name' to use workspace mode"
            echo ""
        fi

        cd "$project_path" || exit 1
        exec claude
    fi
}

# Function to add a project
add_project() {
    local project_path="$1"

    # Resolve to absolute path
    project_path="$(cd "$project_path" 2>/dev/null && pwd)" || {
        echo "Error: Directory not found: $1"
        exit 1
    }

    local project_name=$(basename "$project_path")

    echo ""
    read -p "Project name [$project_name]: " custom_name
    project_name=${custom_name:-$project_name}

    read -p "Description (optional): " description

    # Add to registry
    local temp=$(mktemp)
    jq ".projects[\"$project_name\"] = {\"path\": \"$project_path\", \"description\": \"$description\", \"status\": \"active\"}" "$REGISTRY" > "$temp"
    mv "$temp" "$REGISTRY"

    echo ""
    echo "✓ Added '$project_name' to registry"
    echo ""

    if [ ! -f "$project_path/.claude-workspace.json" ]; then
        read -p "Create .claude-workspace.json? [Y/n] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            exec "$SCRIPT_DIR/setup.sh" "$project_path"
        fi
    fi
}

# Function to list projects
list_projects() {
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════════════════╗"
    echo "║  Registered Projects                                                         ║"
    echo "╚══════════════════════════════════════════════════════════════════════════════╝"
    echo ""

    jq -r '.projects | to_entries[] | "\(.key)\t\(.value.path)\t\(.value.description // \"\")"' "$REGISTRY" 2>/dev/null | while IFS=$'\t' read -r name path desc;
    do
        local workspace_indicator=""
        [ -f "$path/.claude-workspace.json" ] && workspace_indicator=" [workspace]"

        echo "  $name$workspace_indicator"
        echo "    Path: $path"
        [ -n "$desc" ] && echo "    Description: $desc"
        echo ""
    done
}

# Check for help flag first
if [ "$1" = "-h" ] || [ "$1" = "--help" ] || [ "$1" = "help" ]; then
    show_help
    exit 0
fi

if [ "$1" = "--version" ] || [ "$1" = "-v" ]; then
    echo "claude-workspace version $VERSION"
    exit 0
fi

# Handle subcommands
case "$1" in
    setup)
        exec "$SCRIPT_DIR/setup.sh"
        ;;
    add)
        if [ -z "$2" ]; then
            echo "Usage: claude-workspace add <path>"
            exit 1
        fi
        add_project "$2"
        exit 0
        ;;
    list)
        list_projects
        exit 0
        ;;
    settings)
        exec "$SCRIPT_DIR/settings.sh" "${@:2}"
        ;;
    update)
        echo ""
        echo "╔══════════════════════════════════════════════════════════════════════════════╗"
        echo "║  Updating Claude Workspace...                                                ║"
        echo "╚══════════════════════════════════════════════════════════════════════════════╝"
        echo ""

        # Check for git repo
        if [ -d "$HOME/.claude-workspace/.git" ]; then
            echo "Updating via git..."
            cd "$HOME/.claude-workspace"
            git fetch origin
            LOCAL=$(git rev-parse HEAD)
            REMOTE=$(git rev-parse origin/main)
            if [ "$LOCAL" = "$REMOTE" ]; then
                echo "✓ Already up to date (v$VERSION)"
            else
                git pull origin main
                echo ""
                echo "✓ Updated successfully!"
                NEW_VERSION=$(grep "^VERSION=" "$SCRIPT_DIR/ai-project" | cut -d'"' -f2)
                echo "  New version: $NEW_VERSION"
            fi
        else
            echo "Updating via install script..."
            curl -fsSL https://raw.githubusercontent.com/malipetek/claude-workspace/main/install.sh | bash
        fi
        echo ""
        exit 0
        ;;
esac

# Check for simple mode flag
FORCE_MODE=""
if [ "$1" = "--simple" ] || [ "$1" = "-s" ]; then
    FORCE_MODE="simple"
    shift
fi

if [ "$1" = "--workspace" ] || [ "$1" = "-w" ]; then
    FORCE_MODE="workspace"
    shift
fi

# Ensure directories exist
mkdir -p "$HOME/.claude-workspace"/{scripts,logs,dev-logs,status,dev-markers}

if [ ! -f "$REGISTRY" ]; then
    echo '{"projects":{}}' > "$REGISTRY"
fi

# Check if jq is available
if ! command -v jq &> /dev/null; then
    echo "Error: jq is required"
    echo "Install with: brew install jq"
    exit 1
fi

# Interactive Main Menu
interactive_project_select() {
    # Get all project names
    local -a project_names=($(jq -r '.projects | keys[]' "$REGISTRY" 2>/dev/null))
    
    # Build menu items
    local -a ids=()
    local -a labels=()
    local -a descs=()
    local -a types=() # item or separator
    
    # Add Projects
    if [ ${#project_names[@]} -gt 0 ]; then
        types+=("separator")
        labels+=("Projects")
        ids+=("")
        descs+=("")
        
        for name in "${project_names[@]}"; do
            local proj_path=$(jq -r ".projects[\"$name\"].path" "$REGISTRY")
            local indicator=""
            if [ -f "$proj_path/.claude-workspace.json" ]; then
                local count=$(jq '.processes | length' "$proj_path/.claude-workspace.json" 2>/dev/null || echo 0)
                [ "$count" -gt 0 ] && indicator="$count processes"
            fi
            
            types+=("item")
            ids+=("project:$name")
            labels+=("$name")
            descs+=("$indicator")
        done
    fi
    
    # Add Commands
    types+=("separator")
    labels+=("Commands")
    ids+=("")
    descs+=("")
    
    types+=("item"); ids+=("cmd:setup"); labels+=("Setup Wizard"); descs+=("Configure projects and workspaces")
    types+=("item"); ids+=("cmd:settings"); labels+=("Settings"); descs+=("AI tools and delegation")
    types+=("item"); ids+=("cmd:add"); labels+=("Add Project"); descs+=("Add a new project")
    types+=("item"); ids+=("cmd:list"); labels+=("List Projects"); descs+=("Show all registered projects")
    types+=("item"); ids+=("cmd:update"); labels+=("Update"); descs+=("Update to latest version")
    types+=("item"); ids+=("cmd:help"); labels+=("Help"); descs+=("Show documentation")
    
    local total=${#ids[@]}
    local current=0
    
    # Find first selectable item
    while [ "${types[$current]}" = "separator" ] && [ $current -lt $total ]; do
        ((current++))
    done
    
    local ITEMS_ROW=4
    
    enter_alt_screen
    hide_cursor
    trap 'show_cursor; exit_alt_screen' EXIT
    
    draw_header() {
        goto_row 1
        clear_line
        echo ""
        clear_line
        echo -e "    ${TEXT}${BOLD}Claude Workspace${NC} ${TEXT_MUTED}v${VERSION}${NC}                                       ${TEXT_MUTED}esc${NC}"
        echo ""
    }
    
    draw_item() {
        local i=$1
        local row=$((ITEMS_ROW + i))
        
        goto_row $row
        clear_line
        
        local type="${types[$i]}"
        local label="${labels[$i]}"
        local desc="${descs[$i]}"
        
        if [ "$type" = "separator" ]; then
            if [ -n "$label" ]; then
                echo -e "    ${ACCENT}${BOLD}${label}${NC}"
            else
                echo ""
            fi
            return
        fi
        
        if [ $i -eq $current ]; then
            local line_content=" ${label}"
            local desc_content=""
            [ -n "$desc" ] && desc_content=" ${TEXT_DIM}${desc}${NC}"
            
            # Pad background
            echo -e "    ${PRIMARY_BG}${PRIMARY_FG}${BOLD}${line_content}${NC}${PRIMARY_BG}${PRIMARY_FG}${desc_content} ${NC}"
        else
            echo -e "     ${TEXT}${label}${NC} ${TEXT_MUTED}${desc}${NC}"
        fi
    }
    
    draw_all() {
        for ((i=0; i<total; i++)); do
            draw_item $i
        done
        goto_row $((ITEMS_ROW + total + 1))
        clear_below
    }
    
    draw_header
    draw_all
    
    while true; do
        read -rsn1 key
        
        local prev=$current
        
        case "$key" in
            q|Q) 
                show_cursor
                exit_alt_screen
                trap - EXIT
                exit 0
                ;; 
            w|W) 
                local id="${ids[$current]}"
                if [[ "$id" == project:* ]]; then
                    MENU_RESULT="$id"
                    FORCE_MODE="workspace"
                    show_cursor
                    exit_alt_screen
                    trap - EXIT
                    return 0
                fi
                ;; 
            s|S) 
                local id="${ids[$current]}"
                if [[ "$id" == project:* ]]; then
                    MENU_RESULT="$id"
                    FORCE_MODE="simple"
                    show_cursor
                    exit_alt_screen
                    trap - EXIT
                    return 0
                fi
                ;; 
            ""|
) # Enter
                MENU_RESULT="${ids[$current]}"
                show_cursor
                exit_alt_screen
                trap - EXIT
                return 0
                ;; 
            $''\x1b')
                read -rsn2 -t 1 seq
                if [ -z "$seq" ]; then
                    show_cursor
                    exit_alt_screen
                    trap - EXIT
                    exit 0
                fi
                
                case "$seq" in
                    '[A') # Up
                        while true; do
                            ((current--))
                            [ $current -lt 0 ] && current=$((total - 1))
                            [ "${types[$current]}" != "separator" ] && break
                        done
                        if [ $prev -ne $current ]; then
                            draw_item $prev
                            draw_item $current
                        fi
                        ;; 
                    '[B') # Down
                        while true; do
                            ((current++))
                            [ $current -ge $total ] && current=0
                            [ "${types[$current]}" != "separator" ] && break
                        done
                        if [ $prev -ne $current ]; then
                            draw_item $prev
                            draw_item $current
                        fi
                        ;; 
                esac
                ;; 
        esac
    done
}

# Run the menu
interactive_project_select

# Get the selected result
SELECTED_RESULT="$MENU_RESULT"

# Handle empty result
if [ -z "$SELECTED_RESULT" ]; then
    echo "No selection made"
    exit 0
fi

# Parse result and handle selection
case "$SELECTED_RESULT" in
    project:*) 
        PROJECT_NAME="${SELECTED_RESULT#project:}"
        PROJECT_PATH=$(jq -r ".projects[\"$PROJECT_NAME\"].path" "$REGISTRY")

        if [ ! -d "$PROJECT_PATH" ]; then
            echo "Error: Project directory not found: $PROJECT_PATH"
            exit 1
        fi

        launch_project "$PROJECT_PATH" "$FORCE_MODE"
        ;; 
    cmd:setup)
        exec "$SCRIPT_DIR/setup.sh"
        ;; 
    cmd:settings)
        exec "$SCRIPT_DIR/settings.sh"
        ;; 
    cmd:add)
        echo ""
        read -p "Project path: " project_path
        project_path="${project_path/#\~/$HOME}"
        if [ -d "$project_path" ]; then
            add_project "$project_path"
        else
            echo "Error: Directory not found"
            exit 1
        fi
        ;; 
    cmd:list)
        list_projects
        ;; 
    cmd:update)
        echo ""
        echo "╔══════════════════════════════════════════════════════════════════════════════╗"
        echo "║  Updating Claude Workspace...                                                ║"
        echo "╚══════════════════════════════════════════════════════════════════════════════╝"
        echo ""

        if [ -d "$HOME/.claude-workspace/.git" ]; then
            echo "Updating via git..."
            cd "$HOME/.claude-workspace"
            git fetch origin
            LOCAL=$(git rev-parse HEAD)
            REMOTE=$(git rev-parse origin/main)
            if [ "$LOCAL" = "$REMOTE" ]; then
                echo "✓ Already up to date (v$VERSION)"
            else
                git pull origin main
                echo ""
                echo "✓ Updated successfully!"
                NEW_VERSION=$(grep "^VERSION=" "$SCRIPT_DIR/ai-project" | cut -d'"' -f2)
                echo "  New version: $NEW_VERSION"
            fi
        else
            echo "Updating via install script..."
            curl -fsSL https://raw.githubusercontent.com/malipetek/claude-workspace/main/install.sh | bash
        fi
        ;; 
    cmd:help)
        show_help
        ;; 
esac